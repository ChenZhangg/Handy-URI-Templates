<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>UriTemplate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Handy URI Templates</a> &gt; <a href="index.html" class="el_package">com.damnhandy.uri.template</a> &gt; <span class="el_source">UriTemplate.java</span></div><h1>UriTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2012, Ryan J. McDonough
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.damnhandy.uri.template;

import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Array;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Pattern;

import com.damnhandy.uri.template.impl.Modifier;
import com.damnhandy.uri.template.impl.Operator;
import com.damnhandy.uri.template.impl.UriTemplateParser;
import com.damnhandy.uri.template.impl.VarExploderFactory;
import com.damnhandy.uri.template.impl.VarSpec;

/**
 * &lt;p&gt;
 * This is the primary class for creating and manipulating URI templates. This project implements
 * &lt;a href=&quot;http://tools.ietf.org/html/rfc6570&quot;&gt;RFC6570 URI Templates&lt;/a&gt; and produces output
 * that is compliant with the spec. The template processor supports &lt;a href=&quot;http://tools.ietf.org/html/rfc6570#section-2.0&quot;&gt;levels
 * 1 through 4&lt;/a&gt;. In addition to supporting {@link Map}
 * and {@link List} values as composite types, the library also supports the use of Java objects
 * as well. Please see the {@link VarExploder} and {@link DefaultVarExploder} for more info.
 * &lt;/p&gt;
 * &lt;h3&gt;Basic Usage:&lt;/h3&gt;
 * &lt;p&gt;
 * There are many ways to use this library. The simplest way is to create a template from a
 * URI template  string:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * UriTemplate template = UriTemplate.fromTemplate(&quot;http://example.com/search{?q,lang}&quot;);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Replacement values are added by calling the {@link #set(String, Object)} method on the template:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * template.set(&quot;q&quot;,&quot;cat&quot;)
 *         .set(&quot;lang&quot;,&quot;en&quot;);
 * String uri = template.expand();
 * &lt;/pre&gt;
 * &lt;p&gt;The {@link #expand()} method will replace the variable names with the supplied values
 * and return the following URI:&lt;/p&gt;
 * &lt;pre&gt;
 * http://example.com/search?q=cat&amp;lang=en
 * &lt;/pre&gt;
 *
 *
 * @author &lt;a href=&quot;ryan@damnhandy.com&quot;&gt;Ryan J. McDonough&lt;/a&gt;
 * @version $Revision: 1.1 $
 * @since 1.0
 */
public class UriTemplate implements Serializable
{



   /** The serialVersionUID */
   private static final long serialVersionUID = -5245084430838445979L;

<span class="pc" id="L87">   public static enum Encoding {</span>
<span class="fc" id="L88">      U, UR;</span>
   }

   public static final String DEFAULT_SEPARATOR = &quot;,&quot;;

   /**
    *
    */
<span class="fc" id="L96">   protected DateFormat defaultDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;);</span>

   /**
    *
    */
<span class="fc" id="L101">   static final char[] OPERATORS =</span>
   {'+', '#', '.', '/', ';', '?', '&amp;', '!', '='};

   /**
    *
    */
<span class="fc" id="L107">   private static final BitSet OPERATOR_BITSET = new BitSet();</span>

   static
   {
<span class="fc bfc" id="L111" title="All 2 branches covered.">      for (int i = 0; i &lt; OPERATORS.length; i++)</span>
      {
<span class="fc" id="L113">         OPERATOR_BITSET.set(OPERATORS[i]);</span>
      }
<span class="fc" id="L115">   }</span>

   /**
    * The URI template String
    */
   private String template;
   
   /**
    * A regex string that matches the a URI to the template pattern
    */
   private Pattern reverseMatchPattern;

   /**
    * The collection of values that will be applied to the URI expression in the
    * expansion process.
    */
<span class="fc" id="L131">   private Map&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();</span>

   /**
    * 
    */
   private LinkedList&lt;UriTemplateComponent&gt; components;

   /**
    *
    */
   private Expression[] expressions;
   
   /**
    * 
    */
   private String[] variables;

   /**
    * 
    * Create a new UriTemplate.
    * 
    * @param template
    * @throws MalformedUriTemplateException
    */
   private UriTemplate(final String template) throws MalformedUriTemplateException
<span class="fc" id="L156">   {</span>
<span class="fc" id="L157">      this.template = template;</span>
<span class="fc" id="L158">      this.parseTemplateString();</span>
<span class="fc" id="L159">   }</span>

   /**
    * 
    * Create a new UriTemplate.
    * 
    * @param components
    */
   protected UriTemplate(LinkedList&lt;UriTemplateComponent&gt; components)
<span class="fc" id="L168">   {</span>
<span class="fc" id="L169">      this.components = components;</span>
<span class="fc" id="L170">      initExpressions();</span>
<span class="fc" id="L171">      buildTemplateStringFromComponents();</span>
<span class="fc" id="L172">   }</span>
   /**
    * Creates a new {@link UriTemplateBuilder} from the template string.
    *
    * @param templateString
    * @throws MalformedUriTemplateException
    * @return
    * @since 2.0
    */
   public static UriTemplateBuilder buildFromTemplate(String template) throws MalformedUriTemplateException
   {
<span class="fc" id="L183">      return new UriTemplateBuilder(template);</span>
   }

   /**
    * &lt;p&gt;
    * Creates a new {@link UriTemplateBuilder} from a root {@link UriTemplate}. This
    * method will create a new {@link UriTemplate} from the base and copy the variables
    * from the base template to the new {@link UriTemplate}.
    * &lt;/p&gt;
    * &lt;p&gt;
    * This method is useful when the base template is less volatile than the child
    * expression and you want to merge the two.
    * &lt;/p&gt;
    * @param base
    * @return
    * @since 2.0
    */
   public static UriTemplateBuilder buildFromTemplate(UriTemplate template) throws MalformedUriTemplateException
   {
<span class="fc" id="L202">      return new UriTemplateBuilder(template);</span>
   }

   /**
    * Creates a new {@link UriTemplate} from the template.
    *
    * @param templateString
    * @return
    * @since 2.0
    */
   public static final UriTemplate fromTemplate(final String templateString) throws MalformedUriTemplateException
   {
<span class="fc" id="L214">      return new UriTemplate(templateString);</span>
   }

   /**
    * &lt;p&gt;
    * Creates a new {@link UriTemplate} from a root {@link UriTemplate}. This
    * method will create a new {@link UriTemplate} from the base and copy the variables
    * from the base template to the new {@link UriTemplate}.
    * &lt;/p&gt;
    * &lt;p&gt;
    * This method is useful when the base template is less volatile than the child
    * expression and you want to merge the two.
    * &lt;/p&gt;
    * @param base
    * @return
    * @since 1.0
    */
   public static UriTemplateBuilder fromTemplate(UriTemplate base) throws MalformedUriTemplateException
   {
<span class="nc" id="L233">      return new UriTemplateBuilder(base.getTemplate());</span>
   }

   
   /**
    * Returns the number of expressions found in this template
    *
    * @return
    */
   public int expressionCount()
   {
<span class="nc" id="L244">      return expressions.length;</span>
   }

   /**
    * Returns an array of {@link Expression} instances found in this
    * template.
    *
    * @return
    */
   public Expression[] getExpressions()
   {
<span class="nc" id="L255">      return expressions;</span>
   }

   /**
    * Returns the list of unique variable names, from all {@link Expression}'s, in this template.
    *
    * 
    * @return
    */
   public String[] getVariables()
   {
<span class="nc bnc" id="L266" title="All 2 branches missed.">      if(variables == null)</span>
      {
<span class="nc" id="L268">         Set&lt;String&gt; vars = new LinkedHashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">         for(Expression e : getExpressions())</span>
         {
<span class="nc bnc" id="L271" title="All 2 branches missed.">            for(VarSpec v : e.getVarSpecs())</span>
            {
<span class="nc" id="L273">               vars.add(v.getVariableName());</span>
<span class="nc" id="L274">            }</span>
         }
<span class="nc" id="L276">         variables = vars.toArray(new String[vars.size()]);</span>
      }
<span class="nc" id="L278">      return variables;</span>
   }
   /**
    * Parse the URI template string into the template model.
    *
    */
   protected void parseTemplateString() throws MalformedUriTemplateException
   {
<span class="fc" id="L286">      final String templateString = getTemplate();</span>
<span class="fc" id="L287">      final UriTemplateParser scanner = new UriTemplateParser();</span>
<span class="fc" id="L288">      this.components = scanner.scan(templateString);</span>
<span class="fc" id="L289">      initExpressions();</span>
<span class="fc" id="L290">   }</span>

   /** 
    *  Initializes the collection of expressions in the template.
    */
   private void initExpressions()
   {
<span class="fc" id="L297">      final List&lt;Expression&gt; expressionList = new LinkedList&lt;Expression&gt;();</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">      for (UriTemplateComponent c : components)</span>
      {
<span class="fc bfc" id="L300" title="All 2 branches covered.">         if (c instanceof Expression)</span>
         {
<span class="fc" id="L302">            expressionList.add((Expression) c);</span>
         }

<span class="fc" id="L305">      }</span>
<span class="fc" id="L306">      expressions = expressionList.toArray(new Expression[expressionList.size()]);</span>
<span class="fc" id="L307">   }</span>
   
   
   private void buildTemplateStringFromComponents()
   {
<span class="fc" id="L312">      StringBuilder b = new StringBuilder();</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">      for(UriTemplateComponent c : components)</span>
      {
<span class="fc" id="L315">         b.append(c.getValue());</span>
<span class="fc" id="L316">      }</span>
<span class="fc" id="L317">      this.template = b.toString();</span>
<span class="fc" id="L318">   }</span>
   
   private void buildReverssMatchRegexFromComponents() 
   {
<span class="nc" id="L322">      StringBuilder b = new StringBuilder();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">      for(UriTemplateComponent c : components)</span>
      {
<span class="nc" id="L325">         b.append(&quot;(&quot;).append(c.getMatchPattern()).append(&quot;)&quot;);</span>
<span class="nc" id="L326">      }</span>
<span class="nc" id="L327">      this.reverseMatchPattern = Pattern.compile(b.toString());</span>
<span class="nc" id="L328">   }</span>
   
   /**
    * Returns the
    * 
    * @return
    */
   protected Pattern getReverseMatchPattern() 
   {
<span class="nc bnc" id="L337" title="All 2 branches missed.">      if(this.reverseMatchPattern == null)</span>
      {
<span class="nc" id="L339">         buildReverssMatchRegexFromComponents();</span>
      }
<span class="nc" id="L341">      return this.reverseMatchPattern;</span>
   }
   /**
    * Expands the given template string using the variable replacements
    * in the supplied {@link Map}.
    *
    * @param templateString
    * @param values
    * @since 1.0
    * @throws MalformedUriTemplateException
    * @throws VariableExpansionException
    * @return
    */
   public static String expand(final String templateString, Map&lt;String, Object&gt; values)
         throws MalformedUriTemplateException, VariableExpansionException
   {
<span class="fc" id="L357">      UriTemplate t = new UriTemplate(templateString);</span>
<span class="fc" id="L358">      t.set(values);</span>
<span class="fc" id="L359">      return t.expand();</span>
   }

   
   /**
    * Expand the URI template using the supplied values
    *
    * @param vars
    *            The values that will be used in the expansion
    *
    * @return the expanded URI as a String
    * @throw VariableExpansionException
    * @since 1.0
    */
   public String expand(Map&lt;String, Object&gt; vars) throws VariableExpansionException
   {
<span class="fc" id="L375">      this.values = vars;</span>
<span class="fc" id="L376">      return expand();</span>
   }



   /**
    * Applies variable substitution the URI Template and returns the expanded
    * URI.
    *
    * @return
    * @throw VariableExpansionException
    * @since 1.0
    */
   public String expand() throws VariableExpansionException
   {
<span class="fc" id="L391">      String template = getTemplate();</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">      for (Expression expression : expressions)</span>
      {
<span class="fc" id="L394">         final String replacement = expressionReplacementString(expression);</span>
<span class="fc" id="L395">         template = template.replaceAll(expression.getReplacementPattern(), replacement);</span>
      }
<span class="fc" id="L397">      return template;</span>
   }
   /**
    * Returns the original URI template expression.
    *
    * @return
    * @since 1.1.4
    */
   public String getTemplate()
   {
<span class="fc" id="L407">      return template;</span>
   }

   /**
    * Returns the collection of name/value pairs contained in the instance.
    *
    * @return
    * @since 1.0
    */
   public Map&lt;String, Object&gt; getValues()
   {
<span class="fc" id="L418">      return this.values;</span>
   }

   /**
    *
    * @param dateFormatString
    * @return
    * @since 1.0
    */
   public UriTemplate withDefaultDateFormat(String dateFormatString)
   {
<span class="fc" id="L429">      return this.withDefaultDateFormat(new SimpleDateFormat(dateFormatString));</span>
   }

   /**
    *
    * @param dateFormat
    * @return
    * @since 1.0
    */
   public UriTemplate withDefaultDateFormat(DateFormat dateFormat)
   {
<span class="fc" id="L440">      defaultDateFormat = dateFormat;</span>
<span class="fc" id="L441">      return this;</span>
   }

   /**
    * Sets a value on the URI template expression variable.
    *
    * @param variableName
    * @param value
    * @return
    * @since 1.0
    */
   public UriTemplate set(String variableName, Object value)
   {
<span class="fc" id="L454">      values.put(variableName, value);</span>
<span class="fc" id="L455">      return this;</span>
   }

   /**
    * Returns true if the {@link UriTemplate} contains the variableName.
    *
    * @param variableName
    * @return
    */
   public boolean hasVariable(String variableName)
   {
<span class="nc" id="L466">      return values.containsKey(variableName);</span>
   }

   /**
    * FIXME Comment this
    *
    * @param variableName
    * @return
    */
   public Object get(String variableName)
   {
<span class="nc" id="L477">      return values.get(variableName);</span>
   }

   /**
    * Sets a Date value into the list of variable substitutions using the
    * default {@link DateFormat}.
    *
    * @param variableName
    * @param value
    * @return
    * @since 1.0
    *
    */
   public UriTemplate set(String variableName, Date value)
   {
<span class="fc" id="L492">      values.put(variableName, value);</span>
<span class="fc" id="L493">      return this;</span>
   }

   /**
    * Adds the name/value pairs in the supplied {@link Map} to the collection
    * of values within this URI template instance.
    *
    * @param values
    * @return
    * @since 1.0
    */
   public UriTemplate set(Map&lt;String, Object&gt; values)
   {
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">      if (values != null)</span>
      {
<span class="fc bfc" id="L508" title="All 2 branches covered.">         if (!values.isEmpty())</span>
         {
<span class="fc" id="L510">            this.values.putAll(values);</span>
         }
      }
<span class="fc" id="L513">      return this;</span>
   }

   /**
    *
    *
    * @param op
    * @return
    */
   public static boolean containsOperator(String op)
   {
<span class="fc" id="L524">      return OPERATOR_BITSET.get(op.toCharArray()[0]);</span>
   }



   /**
    *
    *
    * @param operator
    * @param varSpecs
    * @throws VariableExpansionException
    * @return
    */
   private String expressionReplacementString(Expression expression) throws VariableExpansionException
   {
<span class="fc" id="L539">      final Operator operator = expression.getOperator();</span>
<span class="fc" id="L540">      final List&lt;String&gt; replacements = expandVariables(expression);</span>
<span class="fc" id="L541">      String result = joinParts(operator.getSeparator(), replacements);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">      if (result != null)</span>
      {
<span class="fc bfc" id="L544" title="All 2 branches covered.">         if (operator != Operator.RESERVED)</span>
         {
<span class="fc" id="L546">            result = operator.getPrefix() + result;</span>
         }
      }
      else
      {
<span class="fc" id="L551">         result = &quot;&quot;;</span>
      }
<span class="fc" id="L553">      return result;</span>
   }

   /**
    *
    *
    * @param operator
    * @param varSpecs
    * @throws VariableExpansionException
    * @return
    */
   @SuppressWarnings(
   {&quot;rawtypes&quot;, &quot;unchecked&quot;})
   private List&lt;String&gt; expandVariables(Expression expression) throws VariableExpansionException
   {
<span class="fc" id="L568">      final List&lt;String&gt; replacements = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L569">      final Operator operator = expression.getOperator();</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">      for (VarSpec varSpec : expression.getVarSpecs())</span>
      {
<span class="fc bfc" id="L572" title="All 2 branches covered.">         if (values.containsKey(varSpec.getVariableName()))</span>
         {
<span class="fc" id="L574">            Object value = values.get(varSpec.getVariableName());</span>
<span class="fc" id="L575">            String expanded = null;</span>

<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (value != null)</span>
            {
<span class="fc bfc" id="L579" title="All 2 branches covered.">               if (value.getClass().isArray())</span>
               {
<span class="fc bfc" id="L581" title="All 2 branches covered.">                  if (value instanceof char[][])</span>
                  {
<span class="fc" id="L583">                     final char[][] chars = (char[][]) value;</span>
<span class="fc" id="L584">                     final List&lt;String&gt; strings = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">                     for (char[] c : chars)</span>
                     {
<span class="fc" id="L587">                        strings.add(String.valueOf(c));</span>
                     }
<span class="fc" id="L589">                     value = strings;</span>
<span class="fc" id="L590">                  }</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">                  else if (value instanceof char[])</span>
                  {
<span class="fc" id="L593">                     value = String.valueOf((char[]) value);</span>
                  }
                  else
                  {
<span class="fc" id="L597">                     value = arrayToList(value);</span>
                  }

               }
            }
<span class="fc" id="L602">            final boolean explodable = isExplodable(value);</span>
<span class="fc bfc" id="L603" title="All 4 branches covered.">            if (explodable &amp;&amp; varSpec.getModifier() == Modifier.PREFIX)</span>
            {
<span class="fc" id="L605">               throw new VariableExpansionException(</span>
                     &quot;Prefix modifiers are not applicable to variables that have composite values.&quot;);
            }

<span class="fc bfc" id="L609" title="All 2 branches covered.">            if (explodable)</span>
            {
               final VarExploder exploder;
<span class="fc bfc" id="L612" title="All 2 branches covered.">               if (value instanceof VarExploder)</span>
               {
<span class="fc" id="L614">                  exploder = (VarExploder) value;</span>
               }
               else
               {
<span class="fc" id="L618">                  exploder = VarExploderFactory.getExploder(value, varSpec);</span>
               }
<span class="fc bfc" id="L620" title="All 2 branches covered.">               if (varSpec.getModifier() == Modifier.EXPLODE)</span>
               {
<span class="fc" id="L622">                  expanded = expandMap(operator, varSpec, exploder.getNameValuePairs());</span>
               }
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">               else if (varSpec.getModifier() != Modifier.EXPLODE)</span>
               {
<span class="fc" id="L626">                  expanded = expandCollection(operator, varSpec, exploder.getValues());</span>
               }
            }

            /*
             * Format the date if we have a java.util.Date
             */
<span class="fc bfc" id="L633" title="All 2 branches covered.">            if (value instanceof Date)</span>
            {
<span class="fc" id="L635">               value = defaultDateFormat.format((Date) value);</span>
            }
            /*
             * The variable value contains a list of values
             */
<span class="fc bfc" id="L640" title="All 2 branches covered.">            if (value instanceof Collection)</span>
            {
<span class="fc" id="L642">               expanded = this.expandCollection(operator, varSpec, (Collection) value);</span>
            }
            /*
             * The variable value contains a list of key-value pairs
             */
<span class="fc bfc" id="L647" title="All 2 branches covered.">            else if (value instanceof Map)</span>
            {
<span class="fc" id="L649">               expanded = expandMap(operator, varSpec, (Map) value);</span>
            }
            /*
             * The variable value is null or has o value.
             */
<span class="fc bfc" id="L654" title="All 2 branches covered.">            else if (value == null)</span>
            {
<span class="fc" id="L656">               expanded = null;</span>
            }
<span class="fc bfc" id="L658" title="All 2 branches covered.">            else if (expanded == null)</span>
            {
<span class="fc" id="L660">               expanded = this.expandStringValue(operator, varSpec, value.toString(), VarSpec.VarFormat.SINGLE);</span>
            }
<span class="fc bfc" id="L662" title="All 2 branches covered.">            if (expanded != null)</span>
            {
<span class="fc" id="L664">               replacements.add(expanded);</span>
            }

         }
<span class="fc" id="L668">      }</span>
<span class="fc" id="L669">      return replacements;</span>
   }

   /**
    *
    *
    * @param value
    * @return
    */
   private boolean isExplodable(Object value)
   {
<span class="fc bfc" id="L680" title="All 2 branches covered.">      if (value == null)</span>
      {
<span class="fc" id="L682">         return false;</span>
      }
<span class="pc bpc" id="L684" title="1 of 6 branches missed.">      if (value instanceof Collection || value instanceof Map || value.getClass().isArray())</span>
      {
<span class="fc" id="L686">         return true;</span>
      }
<span class="fc bfc" id="L688" title="All 2 branches covered.">      if (!isSimpleType(value))</span>
      {
<span class="fc" id="L690">         return true;</span>
      }
<span class="fc" id="L692">      return false;</span>
   }

   /**
    * Returns true of the object is:
    *
    * &lt;ul&gt;
    * &lt;li&gt;a primitive type&lt;/li&gt;
    * &lt;li&gt;an instance of {@link CharSequence}&lt;/li&gt;
    * &lt;li&gt;an instance of {@link Number} &lt;li&gt;
    * &lt;li&gt;an instance of {@link Date} &lt;li&gt;
    * &lt;/ul&gt;
    *
    * @param value
    * @return
    */
   private boolean isSimpleType(Object value)
   {

<span class="pc bpc" id="L711" title="1 of 10 branches missed.">      if (value.getClass().isPrimitive() || value instanceof Number || value instanceof CharSequence</span>
            || value instanceof Date || value instanceof Boolean)
      {
<span class="fc" id="L714">         return true;</span>
      }

<span class="fc" id="L717">      return false;</span>
   }

   /**
    *
    *
    * @param operator
    * @param varSpec
    * @param variable
    * @return
    */
   private String expandCollection(Operator operator, VarSpec varSpec, Collection&lt;?&gt; variable)
         throws VariableExpansionException
   {

<span class="pc bpc" id="L732" title="1 of 4 branches missed.">      if (variable == null || variable.isEmpty())</span>
      {
<span class="fc" id="L734">         return null;</span>
      }

<span class="fc" id="L737">      final List&lt;String&gt; stringValues = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L738">      final Iterator&lt;?&gt; i = variable.iterator();</span>
<span class="fc" id="L739">      String separator = operator.getSeparator();</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">      if (varSpec.getModifier() != Modifier.EXPLODE)</span>
      {
<span class="fc" id="L742">         separator = operator.getListSeparator();</span>
      }
<span class="fc bfc" id="L744" title="All 2 branches covered.">      while (i.hasNext())</span>
      {
<span class="fc" id="L746">         final Object obj = i.next();</span>
<span class="fc" id="L747">         checkValue(obj);</span>
<span class="fc" id="L748">         final String value = obj.toString();</span>
<span class="fc" id="L749">         stringValues.add(expandStringValue(operator, varSpec, value, VarSpec.VarFormat.ARRAY));</span>
<span class="fc" id="L750">      }</span>

<span class="fc bfc" id="L752" title="All 4 branches covered.">      if (varSpec.getModifier() != Modifier.EXPLODE &amp;&amp; operator.useVarNameWhenExploded())</span>
      {
<span class="fc" id="L754">         final String parts = joinParts(separator, stringValues);</span>
<span class="pc bpc" id="L755" title="1 of 4 branches missed.">         if (operator == Operator.QUERY &amp;&amp; parts == null)</span>
         {
<span class="nc" id="L757">            return varSpec.getVariableName() + &quot;=&quot;;</span>
         }
<span class="fc" id="L759">         return varSpec.getVariableName() + &quot;=&quot; + parts;</span>
      }
<span class="fc" id="L761">      return joinParts(separator, stringValues);</span>
   }

   /**
    * Check to ensure that the values being passed down do not contain nested data structures.
    * @param obj
    */
   private void checkValue(Object obj) throws VariableExpansionException
   {
<span class="pc bpc" id="L770" title="2 of 6 branches missed.">      if (obj instanceof Collection || obj instanceof Map || obj.getClass().isArray())</span>
      {
<span class="fc" id="L772">         throw new VariableExpansionException(&quot;Nested data structures are not supported.&quot;);</span>
      }
<span class="fc" id="L774">   }</span>

   /**
    *
    *
    * @param operator
    * @param varSpec
    * @param variable
    * @return
    */
   private String expandMap(Operator operator, VarSpec varSpec, Map&lt;String, Object&gt; variable)
         throws VariableExpansionException
   {
<span class="pc bpc" id="L787" title="1 of 4 branches missed.">      if (variable == null || variable.isEmpty())</span>
      {
<span class="fc" id="L789">         return null;</span>
      }

<span class="fc" id="L792">      List&lt;String&gt; stringValues = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L793">      String pairJoiner = &quot;=&quot;;</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">      if (varSpec.getModifier() != Modifier.EXPLODE)</span>
      {
<span class="fc" id="L796">         pairJoiner = &quot;,&quot;;</span>
      }
<span class="fc" id="L798">      String joiner = operator.getSeparator();</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">      if (varSpec.getModifier() != Modifier.EXPLODE)</span>
      {
<span class="fc" id="L801">         joiner = operator.getListSeparator();</span>
      }
<span class="fc bfc" id="L803" title="All 2 branches covered.">      for (Entry&lt;String, Object&gt; entry : variable.entrySet())</span>
      {

<span class="fc" id="L806">         String key = entry.getKey();</span>
<span class="fc" id="L807">         checkValue(entry.getValue());</span>
<span class="fc" id="L808">         String pair = expandStringValue(operator, varSpec, key, VarSpec.VarFormat.PAIRS) + pairJoiner</span>
               + expandStringValue(operator, varSpec, entry.getValue().toString(), VarSpec.VarFormat.PAIRS);

<span class="fc" id="L811">         stringValues.add(pair);</span>
<span class="fc" id="L812">      }</span>

<span class="fc bfc" id="L814" title="All 8 branches covered.">      if (varSpec.getModifier() != Modifier.EXPLODE</span>
            &amp;&amp; (operator == Operator.MATRIX || operator == Operator.QUERY || operator == Operator.CONTINUATION))
      {
<span class="fc" id="L817">         String joinedValues = joinParts(joiner, stringValues);</span>
<span class="pc bpc" id="L818" title="1 of 4 branches missed.">         if (operator == Operator.QUERY &amp;&amp; joinedValues == null)</span>
         {
<span class="nc" id="L820">            return varSpec.getVariableName() + &quot;=&quot;;</span>
         }
<span class="fc" id="L822">         return varSpec.getVariableName() + &quot;=&quot; + joinedValues;</span>
      }

<span class="fc" id="L825">      return joinParts(joiner, stringValues);</span>
   }

   /**
    *
    *
    * @param operator
    * @param varSpec
    * @param variable
    * @param format
    * @return
    */
   private String expandStringValue(Operator operator, VarSpec varSpec, String variable, VarSpec.VarFormat format)
         throws VariableExpansionException
   {
      String expanded;

<span class="fc bfc" id="L842" title="All 2 branches covered.">      if (varSpec.getModifier() == Modifier.PREFIX)</span>
      {
<span class="fc" id="L844">         int position = varSpec.getPosition();</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">         if (position &lt; variable.length())</span>
         {
<span class="fc" id="L847">            variable = variable.substring(0, position);</span>
         }
      }

      try
      {
<span class="fc bfc" id="L853" title="All 2 branches covered.">         if (operator.getEncoding() == Encoding.UR)</span>
         {
<span class="fc" id="L855">            expanded = UriUtil.encodeFragment(variable);</span>
         }
         else
         {
<span class="fc" id="L859">            expanded = UriUtil.encode(variable);</span>
         }
      }
<span class="nc" id="L862">      catch (UnsupportedEncodingException e)</span>
      {
<span class="nc" id="L864">         throw new VariableExpansionException(&quot;Could not expand variable due to a problem URI encoding the value.&quot;, e);</span>
<span class="fc" id="L865">      }</span>

<span class="fc bfc" id="L867" title="All 2 branches covered.">      if (operator.isNamed())</span>
      {
<span class="fc bfc" id="L869" title="All 4 branches covered.">         if (expanded.isEmpty() &amp;&amp; !operator.getSeparator().equals(&quot;&amp;&quot;))</span>
         {
<span class="fc" id="L871">            expanded = varSpec.getValue();</span>
         }
<span class="fc bfc" id="L873" title="All 2 branches covered.">         else if (format == VarSpec.VarFormat.SINGLE)</span>
         {
<span class="fc" id="L875">            expanded = varSpec.getVariableName() + &quot;=&quot; + expanded;</span>
         }

         else
         {
<span class="fc bfc" id="L880" title="All 2 branches covered.">            if (varSpec.getModifier() == Modifier.EXPLODE)</span>
            {
<span class="pc bpc" id="L882" title="1 of 4 branches missed.">               if (operator.useVarNameWhenExploded() &amp;&amp; format != VarSpec.VarFormat.PAIRS)</span>
               {
<span class="fc" id="L884">                  expanded = varSpec.getVariableName() + &quot;=&quot; + expanded;</span>
               }
            }
         }
      }
<span class="fc" id="L889">      return expanded;</span>
   }

   /**
    *
    *
    * @param joiner
    * @param parts
    * @return
    */
   private String joinParts(final String joiner, List&lt;String&gt; parts)
   {
<span class="fc bfc" id="L901" title="All 2 branches covered.">      if (parts.size() == 0)</span>
      {
<span class="fc" id="L903">         return null;</span>
      }

<span class="fc bfc" id="L906" title="All 2 branches covered.">      if (parts.size() == 1)</span>
      {
<span class="fc" id="L908">         return parts.get(0);</span>
      }

<span class="fc" id="L911">      final StringBuilder builder = new StringBuilder();</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">      for (int i = 0; i &lt; parts.size(); i++)</span>
      {
<span class="fc" id="L914">         final String part = parts.get(i);</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">         if (!part.isEmpty())</span>
         {
<span class="fc" id="L917">            builder.append(part);</span>
<span class="pc bpc" id="L918" title="1 of 4 branches missed.">            if (parts.size() &gt; 0 &amp;&amp; i != (parts.size() - 1))</span>
            {
<span class="fc" id="L920">               builder.append(joiner);</span>
            }
         }

      }
<span class="fc" id="L925">      return builder.toString();</span>
   }

   /**
    * Takes an array of objects and converts them to a {@link List}.
    *
    * @param array
    * @return
    */
   private List&lt;Object&gt; arrayToList(Object array) throws VariableExpansionException
   {
<span class="fc" id="L936">      List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L937">      int length = Array.getLength(array);</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">      for (int i = 0; i &lt; length; i++)</span>
      {
<span class="fc" id="L940">         final Object element = Array.get(array, i);</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">         if (element.getClass().isArray())</span>
         {
<span class="fc" id="L943">            throw new VariableExpansionException(&quot;Multi-dimenesional arrays are not supported.&quot;);</span>
         }
<span class="fc" id="L945">         list.add(element);</span>
      }
<span class="fc" id="L947">      return list;</span>
   }

   /**
    *
    * 
    * @return
    */
//   public String getRegexString()
//   {
//      return null;
//   }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span></div></body></html>