<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UriTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Handy URI Templates</a> &gt; <a href="index.source.html" class="el_package">com.damnhandy.uri.template</a> &gt; <span class="el_source">UriTemplate.java</span></div><h1>UriTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2012, Ryan J. McDonough
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.damnhandy.uri.template;

import com.damnhandy.uri.template.impl.*;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Array;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.Map.Entry;
import java.util.regex.Pattern;

/**
 * &lt;p&gt;
 * This is the primary class for creating and manipulating URI templates. This project implements
 * &lt;a href=&quot;http://tools.ietf.org/html/rfc6570&quot;&gt;RFC6570 URI Templates&lt;/a&gt; and produces output
 * that is compliant with the spec. The template processor supports &lt;a href=&quot;http://tools.ietf.org/html/rfc6570#section-2.0&quot;&gt;levels
 * 1 through 4&lt;/a&gt;. In addition to supporting {@link Map}
 * and {@link List} values as composite types, the library also supports the use of Java objects
 * as well. Please see the {@link VarExploder} and {@link DefaultVarExploder} for more info.
 * &lt;/p&gt;
 * &lt;h3&gt;Basic Usage:&lt;/h3&gt;
 * &lt;p&gt;
 * There are many ways to use this library. The simplest way is to create a template from a
 * URI template  string:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * UriTemplate template = UriTemplate.fromTemplate(&quot;http://example.com/search{?q,lang}&quot;);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Replacement values are added by calling the {@link #set(String, Object)} method on the template:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * template.set(&quot;q&quot;,&quot;cat&quot;)
 *         .set(&quot;lang&quot;,&quot;en&quot;);
 * String uri = template.expand();
 * &lt;/pre&gt;
 * &lt;p&gt;The {@link #expand()} method will replace the variable names with the supplied values
 * and return the following URI:&lt;/p&gt;
 * &lt;pre&gt;
 * http://example.com/search?q=cat&amp;apm;lang=en
 * &lt;/pre&gt;
 *
 *
 * @author &lt;a href=&quot;ryan@damnhandy.com&quot;&gt;Ryan J. McDonough&lt;/a&gt;
 * @version $Revision: 1.1 $
 * @since 1.0
 */
public class UriTemplate implements Serializable
{


    /**
     * The serialVersionUID
     */
    private static final long serialVersionUID = -5245084430838445979L;

<span class="fc" id="L77">    public enum Encoding</span>
    {
<span class="fc" id="L79">        U, UR;</span>
    }

    public static final String DEFAULT_SEPARATOR = &quot;,&quot;;

    /**
     *
     */
<span class="fc" id="L87">    transient DateTimeFormatter defaultDateTimeFormatter = DateTimeFormat.forPattern(&quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;);</span>

    /**
     * @deprecated Replaced by {@link #defaultDateTimeFormatter defaultDateTimeFormatter}
     */
<span class="fc" id="L92">    @Deprecated</span>
    protected DateFormat defaultDateFormat = null;

    /**
     *
     */
<span class="fc" id="L98">    private static final char[] OPERATORS =</span>
    {'+', '#', '.', '/', ';', '?', '&amp;', '!', '='};

    /**
     *
     */
<span class="fc" id="L104">    private static final BitSet OPERATOR_BITSET = new BitSet();</span>

    static
    {
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (int i = 0; i &lt; OPERATORS.length; i++)</span>
        {
<span class="fc" id="L110">            OPERATOR_BITSET.set(OPERATORS[i]);</span>
        }
<span class="fc" id="L112">    }</span>

    /**
     * The URI template String
     */
    private String template;

    /**
     * A regex string that matches the a URI to the template pattern
     */
    private Pattern reverseMatchPattern;

    /**
     * The collection of values that will be applied to the URI expression in the
     * expansion process.
     */
<span class="fc" id="L128">    private Map&lt;String, Object&gt; values = new LinkedHashMap&lt;String, Object&gt;();</span>

    /**
     *
     */
    private LinkedList&lt;UriTemplateComponent&gt; components;

    /**
     *
     */
    private List&lt;Expression&gt; expressions;

    /**
     *
     */
    private Set&lt;String&gt; variables;

    /**
     * Create a new UriTemplate.
     *
     * @param template
     * @throws MalformedUriTemplateException
     */
    private UriTemplate(final String template) throws MalformedUriTemplateException
<span class="fc" id="L152">    {</span>
<span class="fc" id="L153">        this.template = template;</span>
<span class="fc" id="L154">        this.parseTemplateString();</span>
<span class="fc" id="L155">    }</span>

    /**
     * Create a new UriTemplate.
     *
     * @param components
     */
    protected UriTemplate(LinkedList&lt;UriTemplateComponent&gt; components)
<span class="fc" id="L163">    {</span>
<span class="fc" id="L164">        this.components = components;</span>
<span class="fc" id="L165">        initExpressions();</span>
<span class="fc" id="L166">        buildTemplateStringFromComponents();</span>
<span class="fc" id="L167">    }</span>

    /**
     * Creates a new {@link UriTemplateBuilder} instance.
     * @return the new UriTemplateBuilder
     * @since 2.1.2
     */
    public static UriTemplateBuilder createBuilder()
    {
<span class="fc" id="L176">        return new UriTemplateBuilder();</span>
    }

    /**
     * Creates a new {@link UriTemplateBuilder} from the template string.
     *
     * @param template
     * @return
     * @throws MalformedUriTemplateException
     * @since 2.0
     */
    public static UriTemplateBuilder buildFromTemplate(String template) throws MalformedUriTemplateException
    {
<span class="fc" id="L189">        return new UriTemplateBuilder(template);</span>
    }

    /**
     * &lt;p&gt;
     * Creates a new {@link UriTemplateBuilder} from a root {@link UriTemplate}. This
     * method will create a new {@link UriTemplate} from the base and copy the variables
     * from the base template to the new {@link UriTemplate}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This method is useful when the base template is less volatile than the child
     * expression and you want to merge the two.
     * &lt;/p&gt;
     *
     * @param baseTemplate
     * @return
     * @since 2.0
     */
    public static UriTemplateBuilder buildFromTemplate(UriTemplate baseTemplate) throws MalformedUriTemplateException
    {
<span class="fc" id="L209">        return new UriTemplateBuilder(baseTemplate);</span>
    }

    /**
     * &lt;p&gt;
     * Creates a new {@link UriTemplate} from the template string.
     * &lt;/p&gt;
     *
     * @param templateString
     * @return
     * @since 2.0
     */
    public static final UriTemplate fromTemplate(final String templateString) throws MalformedUriTemplateException
    {
<span class="fc" id="L223">        return new UriTemplate(templateString);</span>
    }

    /**
     * &lt;p&gt;
     *   This method is now deprecated. Use {@link UriTemplate#buildFromTemplate(UriTemplate)} instead.
     * &lt;/p&gt;
     *
     * @deprecated use {@link #buildFromTemplate(UriTemplate)}
     * @param baseTemplate
     * @return
     * @since 1.0
     */
    @Deprecated
    public static UriTemplateBuilder fromTemplate(UriTemplate baseTemplate) throws MalformedUriTemplateException
    {
<span class="nc" id="L239">        return new UriTemplateBuilder(baseTemplate);</span>
    }

    /**
     * &lt;p&gt;
     * Returns the collection of {@link UriTemplateComponent} instances
     * found in this template.
     * &lt;/p&gt;
     * @return the collection of {@link UriTemplateComponent}s
     */
    public Collection&lt;UriTemplateComponent&gt; getComponents() {
<span class="fc" id="L250">        return Collections.unmodifiableCollection(components);</span>
    }

    /**
     * Returns the number of expressions found in this template
     *
     * @return
     */
    public int expressionCount()
    {
<span class="nc" id="L260">        return expressions.size();</span>
    }

    /**
     * Returns an array of {@link Expression} instances found in this
     * template.
     *
     * @return
     */
    public Expression[] getExpressions()
    {
<span class="nc" id="L271">        return expressions.toArray(new Expression[expressions.size()]);</span>
    }

    /**
     * Returns the list of unique variable names, from all {@link Expression}'s, in this template.
     *
     * @return
     */
    public String[] getVariables()
    {
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (variables == null)</span>
        {
<span class="nc" id="L283">            variables = new LinkedHashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">            for (Expression e : getExpressions())</span>
            {
<span class="nc bnc" id="L286" title="All 2 branches missed.">                for (VarSpec v : e.getVarSpecs())</span>
                {
<span class="nc" id="L288">                    variables.add(v.getVariableName());</span>
<span class="nc" id="L289">                }</span>
            }
        }
<span class="nc" id="L292">        return variables.toArray(new String[variables.size()]);</span>
    }

    /**
     * Parse the URI template string into the template model.
     */
    protected void parseTemplateString() throws MalformedUriTemplateException
    {
<span class="fc" id="L300">        final String templateString = getTemplate();</span>
<span class="fc" id="L301">        final UriTemplateParser scanner = new UriTemplateParser();</span>
<span class="fc" id="L302">        this.components = scanner.scan(templateString);</span>
<span class="fc" id="L303">        initExpressions();</span>
<span class="fc" id="L304">    }</span>

    /**
     * Initializes the collection of expressions in the template.
     */
    private void initExpressions()
    {
<span class="fc" id="L311">        expressions = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        for (UriTemplateComponent c : components)</span>
        {
<span class="fc bfc" id="L314" title="All 2 branches covered.">            if (c instanceof Expression)</span>
            {
<span class="fc" id="L316">                expressions.add((Expression) c);</span>
            }
<span class="fc" id="L318">        }</span>
<span class="fc" id="L319">    }</span>


    private void buildTemplateStringFromComponents()
    {
<span class="fc" id="L324">        StringBuilder b = new StringBuilder();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">        for (UriTemplateComponent c : components)</span>
        {
<span class="fc" id="L327">            b.append(c.getValue());</span>
<span class="fc" id="L328">        }</span>
<span class="fc" id="L329">        this.template = b.toString();</span>
<span class="fc" id="L330">    }</span>

    private void buildReverseMatchRegexFromComponents()
    {
<span class="nc" id="L334">        StringBuilder b = new StringBuilder();</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">        for (UriTemplateComponent c : components)</span>
        {
<span class="nc" id="L337">            b.append(&quot;(&quot;).append(c.getMatchPattern()).append(&quot;)&quot;);</span>
<span class="nc" id="L338">        }</span>
<span class="nc" id="L339">        this.reverseMatchPattern = Pattern.compile(b.toString());</span>
<span class="nc" id="L340">    }</span>

    /**
     * Returns the
     *
     * @return
     */
    protected Pattern getReverseMatchPattern()
    {
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (this.reverseMatchPattern == null)</span>
        {
<span class="nc" id="L351">            buildReverseMatchRegexFromComponents();</span>
        }
<span class="nc" id="L353">        return this.reverseMatchPattern;</span>
    }

    /**
     * Expands the given template string using the variable replacements
     * in the supplied {@link Map}.
     *
     * @param templateString
     * @param values
     * @return the expanded URI as a String
     * @throws MalformedUriTemplateException
     * @throws VariableExpansionException
     * @since 1.0
     */
    public static String expand(final String templateString, Map&lt;String, Object&gt; values)
    throws MalformedUriTemplateException, VariableExpansionException
    {
<span class="fc" id="L370">        UriTemplate t = new UriTemplate(templateString);</span>
<span class="fc" id="L371">        t.set(values);</span>
<span class="fc" id="L372">        return t.expand();</span>
    }

    /**
     * Expands the given template string using the variable replacements
     * in the supplied {@link Map}. Expressions without replacements get
     * preserved and still exist in the expanded URI string.
     *
     * @param templateString URI template
     * @param values         Replacements
     * @return The expanded URI as a String
     * @throws MalformedUriTemplateException
     * @throws VariableExpansionException
     */
    public static String expandPartial(final String templateString, Map&lt;String, Object&gt; values)
    throws MalformedUriTemplateException, VariableExpansionException
    {
<span class="fc" id="L389">        UriTemplate t = new UriTemplate(templateString);</span>
<span class="fc" id="L390">        t.set(values);</span>
<span class="fc" id="L391">        return t.expandPartial();</span>
    }

    /**
     * Expand the URI template using the supplied values
     *
     * @param vars The values that will be used in the expansion
     * @return the expanded URI as a String
     * @throw VariableExpansionException
     * @since 1.0
     */
    public String expand(Map&lt;String, Object&gt; vars) throws VariableExpansionException
    {
<span class="fc" id="L404">        this.values = vars;</span>
<span class="fc" id="L405">        return expand();</span>
    }


    /**
     * Applies variable substitution the URI Template and returns the expanded
     * URI.
     *
     * @return the expanded URI as a String
     * @throw VariableExpansionException
     * @since 1.0
     */
    public String expand() throws VariableExpansionException
    {
<span class="fc" id="L419">        String template = getTemplate();</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">        for (Expression expression : expressions)</span>
        {
<span class="fc" id="L422">            final String replacement = expressionReplacementString(expression, false);</span>
<span class="fc" id="L423">            template = template.replaceAll(expression.getReplacementPattern(), replacement);</span>
<span class="fc" id="L424">        }</span>
<span class="fc" id="L425">        return template;</span>
    }

    /**
     * @return
     * @throws VariableExpansionException
     */
    public String expandPartial() throws VariableExpansionException
    {
<span class="fc" id="L434">        String template = getTemplate();</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">        for (Expression expression : expressions)</span>
        {
<span class="fc" id="L437">            final String replacement = expressionReplacementString(expression, true);</span>
<span class="fc" id="L438">            template = template.replaceAll(expression.getReplacementPattern(), replacement);</span>
<span class="fc" id="L439">        }</span>
<span class="fc" id="L440">        return template;</span>
    }

    /**
     * Returns the original URI template expression.
     *
     * @return the template string
     * @since 1.1.4
     */
    public String getTemplate()
    {
<span class="fc" id="L451">        return template;</span>
    }

    /**
     * Returns the collection of name/value pairs contained in the instance.
     *
     * @return the name value pairs
     * @since 1.0
     */
    public Map&lt;String, Object&gt; getValues()
    {
<span class="fc" id="L462">        return this.values;</span>
    }

    /**
     * @param dateFormatString
     * @return the date format used to render dates
     * @since 1.0
     */
    public UriTemplate withDefaultDateFormat(String dateFormatString)
    {
<span class="fc" id="L472">        return this.withDefaultDateFormat(DateTimeFormat.forPattern(dateFormatString));</span>
    }

    private UriTemplate withDefaultDateFormat(DateTimeFormatter dateTimeFormatter)
    {
<span class="fc" id="L477">        defaultDateTimeFormatter = dateTimeFormatter;</span>
<span class="fc" id="L478">        return this;</span>
    }

    /**
     * @param dateFormat
     * @return the date format used to render dates
     * @since 1.0
     * @deprecated replaced by {@link #withDefaultDateFormat(String) withDefaultDateFormat}
     */
    @Deprecated
    public UriTemplate withDefaultDateFormat(DateFormat dateFormat)
    {
<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (!(dateFormat instanceof SimpleDateFormat))</span>
        {
<span class="nc" id="L492">            throw new IllegalArgumentException(</span>
            &quot;The only supported subclass of java.text.DateFormat is java.text.SimpleDateFormat&quot;);
        }
<span class="nc" id="L495">        defaultDateTimeFormatter = DateTimeFormat.forPattern(((SimpleDateFormat) dateFormat).toPattern());</span>
<span class="nc" id="L496">        return this;</span>
    }

    /**
     * Sets a value on the URI template expression variable.
     *
     * @param variableName
     * @param value
     * @return
     * @since 1.0
     */
    public UriTemplate set(String variableName, Object value)
    {
<span class="fc" id="L509">        values.put(variableName, value);</span>
<span class="fc" id="L510">        return this;</span>
    }

    /**
     * Returns true if the {@link UriTemplate} contains the variableName.
     *
     * @param variableName
     * @return
     */
    public boolean hasVariable(String variableName)
    {
<span class="nc" id="L521">        return values.containsKey(variableName);</span>
    }

    /**
     * FIXME Comment this
     *
     * @param variableName
     * @return
     */
    public Object get(String variableName)
    {
<span class="nc" id="L532">        return values.get(variableName);</span>
    }

    /**
     * Sets a Date value into the list of variable substitutions using the
     * default {@link DateFormat}.
     *
     * @param variableName
     * @param value
     * @return
     * @since 1.0
     */
    public UriTemplate set(String variableName, Date value)
    {
<span class="fc" id="L546">        values.put(variableName, value);</span>
<span class="fc" id="L547">        return this;</span>
    }

    /**
     * Adds the name/value pairs in the supplied {@link Map} to the collection
     * of values within this URI template instance.
     *
     * @param values
     * @return
     * @since 1.0
     */
    public UriTemplate set(Map&lt;String, Object&gt; values)
    {
<span class="pc bpc" id="L560" title="1 of 4 branches missed.">        if (values != null &amp;&amp; !values.isEmpty())</span>
        {
<span class="fc" id="L562">            this.values.putAll(values);</span>
        }
<span class="fc" id="L564">        return this;</span>
    }

    /**
     * @param op
     * @return
     */
    public static boolean containsOperator(String op)
    {
<span class="fc" id="L573">        return OPERATOR_BITSET.get(op.toCharArray()[0]);</span>
    }


    /**
     * @param expression
     * @param partial
     * @return
     * @throws VariableExpansionException
     */
    private String expressionReplacementString(Expression expression, boolean partial) throws VariableExpansionException
    {
<span class="fc" id="L585">        final Operator operator = expression.getOperator();</span>
<span class="fc" id="L586">        final List&lt;String&gt; replacements = expandVariables(expression, partial);</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">        String result = partial ? joinParts(expression, replacements) : joinParts(operator.getSeparator(), replacements);</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (result != null)</span>
        {
<span class="fc bfc" id="L590" title="All 4 branches covered.">            if (!partial &amp;&amp; operator != Operator.RESERVED)</span>
            {
<span class="fc" id="L592">                result = operator.getPrefix() + result;</span>
            }
        }
        else
        {
<span class="fc" id="L597">            result = &quot;&quot;;</span>
        }
<span class="fc" id="L599">        return result;</span>
    }

    /**
     * @param expression
     * @param partial
     * @return
     * @throws VariableExpansionException
     */
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    private List&lt;String&gt; expandVariables(Expression expression, boolean partial) throws VariableExpansionException
    {
<span class="fc" id="L611">        final List&lt;String&gt; replacements = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L612">        final Operator operator = expression.getOperator();</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">        for (VarSpec varSpec : expression.getVarSpecs())</span>
        {
<span class="fc bfc" id="L615" title="All 2 branches covered.">            if (values.containsKey(varSpec.getVariableName()))</span>
            {
<span class="fc" id="L617">                Object value = values.get(varSpec.getVariableName());</span>
                // The expanded value
<span class="fc" id="L619">                String expanded = null;</span>

<span class="fc bfc" id="L621" title="All 2 branches covered.">                if (value != null)</span>
                {
<span class="fc bfc" id="L623" title="All 2 branches covered.">                    if (value.getClass().isArray())</span>
                    {
<span class="fc bfc" id="L625" title="All 2 branches covered.">                        if (value instanceof char[][])</span>
                        {
<span class="fc" id="L627">                            final char[][] chars = (char[][]) value;</span>
<span class="fc" id="L628">                            final List&lt;String&gt; strings = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">                            for (char[] c : chars)</span>
                            {
<span class="fc" id="L631">                                strings.add(String.valueOf(c));</span>
                            }
<span class="fc" id="L633">                            value = strings;</span>
<span class="fc" id="L634">                        }</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">                        else if (value instanceof char[])</span>
                        {
<span class="fc" id="L637">                            value = String.valueOf((char[]) value);</span>
                        }
                        else
                        {
<span class="fc" id="L641">                            value = arrayToList(value);</span>
                        }

                    }
                }
                // Check to see if the value is explodable, meaning that we need to pass it to VarExploder to
                // decompose the object to simple key/value pairs. We don't handle prefix modifiers on composite values.
<span class="fc" id="L648">                final boolean explodable = isExplodable(value);</span>
<span class="fc bfc" id="L649" title="All 4 branches covered.">                if (explodable &amp;&amp; varSpec.getModifier() == Modifier.PREFIX)</span>
                {
<span class="fc" id="L651">                    throw new VariableExpansionException(</span>
                    &quot;Prefix modifiers are not applicable to variables that have composite values.&quot;);
                }
                // If it's explodable, lookup the appropriate exploder
<span class="fc bfc" id="L655" title="All 2 branches covered.">                if (explodable)</span>
                {
                    final VarExploder exploder;
<span class="fc bfc" id="L658" title="All 2 branches covered.">                    if (value instanceof VarExploder)</span>
                    {
<span class="fc" id="L660">                        exploder = (VarExploder) value;</span>
                    }
                    else
                    {
<span class="fc" id="L664">                        exploder = VarExploderFactory.getExploder(value, varSpec);</span>
                    }
<span class="fc bfc" id="L666" title="All 2 branches covered.">                    if (varSpec.getModifier() == Modifier.EXPLODE)</span>
                    {
<span class="fc" id="L668">                        expanded = expandMap(operator, varSpec, exploder.getNameValuePairs());</span>
                    }
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">                    else if (varSpec.getModifier() != Modifier.EXPLODE)</span>
                    {
<span class="fc" id="L672">                        expanded = expandCollection(operator, varSpec, exploder.getValues());</span>
                    }
                }

                /*
                 * Format the date if we have a java.util.Date
                 */
<span class="fc bfc" id="L679" title="All 2 branches covered.">                if (value instanceof Date)</span>
                {
<span class="fc" id="L681">                    value = defaultDateTimeFormatter.print(new DateTime((Date) value));</span>
                }
                /*
                 * The variable value contains a list of values
                 */
<span class="fc bfc" id="L686" title="All 2 branches covered.">                if (value instanceof Collection)</span>
                {
<span class="fc" id="L688">                    expanded = this.expandCollection(operator, varSpec, (Collection) value);</span>
                }
                /*
                 * The variable value contains a list of key-value pairs
                 */
<span class="fc bfc" id="L693" title="All 2 branches covered.">                else if (value instanceof Map)</span>
                {
<span class="fc" id="L695">                    expanded = expandMap(operator, varSpec, (Map) value);</span>
                }
                /*
                 * The variable value is null or has o value.
                 */
<span class="fc bfc" id="L700" title="All 2 branches covered.">                else if (value == null)</span>
                {
<span class="fc" id="L702">                    expanded = null;</span>
                }
                /*
                 * the value hasn't been expanded yet and we should call toString() on it.
                 */
<span class="fc bfc" id="L707" title="All 2 branches covered.">                else if (expanded == null)</span>
                {
<span class="fc" id="L709">                    expanded = this.expandStringValue(operator, varSpec, value.toString(), VarSpec.VarFormat.SINGLE);</span>
                }
<span class="fc bfc" id="L711" title="All 2 branches covered.">                if (expanded != null)</span>
                {
<span class="fc" id="L713">                    replacements.add(expanded);</span>
                }

<span class="fc" id="L716">            }</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">            else if (partial)</span>
            {
<span class="fc" id="L719">                replacements.add(null);</span>
            }
<span class="fc" id="L721">        }</span>
<span class="fc" id="L722">        return replacements;</span>
    }

    /**
     * @param value
     * @return
     */
    private boolean isExplodable(Object value)
    {
<span class="fc bfc" id="L731" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L733">            return false;</span>
        }
<span class="pc bpc" id="L735" title="1 of 6 branches missed.">        if (value instanceof Collection || value instanceof Map || value.getClass().isArray())</span>
        {
<span class="fc" id="L737">            return true;</span>
        }
<span class="fc bfc" id="L739" title="All 2 branches covered.">        if (!isSimpleType(value))</span>
        {
<span class="fc" id="L741">            return true;</span>
        }
<span class="fc" id="L743">        return false;</span>
    }

    /**
     * Returns true of the object is:
     * &lt;p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;a primitive type&lt;/li&gt;
     * &lt;li&gt;an enum&lt;/li&gt;
     * &lt;li&gt;an instance of {@link CharSequence}&lt;/li&gt;
     * &lt;li&gt;an instance of {@link Number} &lt;li&gt;
     * &lt;li&gt;an instance of {@link Date} &lt;li&gt;
     * &lt;li&gt;an instance of {@link Boolean}&lt;/li&gt;
     * &lt;li&gt;an instance of {@link UUID}&lt;/li&gt;
     * &lt;li&gt;an instance of {@link Class}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param value
     * @return
     */
    private boolean isSimpleType(Object value)
    {

<span class="pc bpc" id="L766" title="1 of 2 branches missed.">        if (value.getClass().isPrimitive()</span>
<span class="pc bpc" id="L767" title="1 of 14 branches missed.">        || value.getClass().isEnum()</span>
        || value instanceof Class
        || value instanceof Number
        || value instanceof CharSequence
        || value instanceof Date
        || value instanceof Boolean
        || value instanceof UUID
        )
        {
<span class="fc" id="L776">            return true;</span>
        }
<span class="fc" id="L778">        return false;</span>
    }

    /**
     * @param operator
     * @param varSpec
     * @param variable
     * @return
     */
    private String expandCollection(Operator operator, VarSpec varSpec, Collection&lt;?&gt; variable)
    throws VariableExpansionException
    {

<span class="pc bpc" id="L791" title="1 of 4 branches missed.">        if (variable == null || variable.isEmpty())</span>
        {
<span class="fc" id="L793">            return null;</span>
        }

<span class="fc" id="L796">        final List&lt;String&gt; stringValues = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L797">        final Iterator&lt;?&gt; i = variable.iterator();</span>
<span class="fc" id="L798">        String separator = operator.getSeparator();</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">        if (varSpec.getModifier() != Modifier.EXPLODE)</span>
        {
<span class="fc" id="L801">            separator = operator.getListSeparator();</span>
        }
<span class="fc bfc" id="L803" title="All 2 branches covered.">        while (i.hasNext())</span>
        {
<span class="fc" id="L805">            final Object obj = i.next();</span>
<span class="fc" id="L806">            checkValue(obj);</span>
            String value;
<span class="fc bfc" id="L808" title="All 2 branches covered.">            if(checkValue(obj))</span>
            {
<span class="fc" id="L810">                value = joinParts(&quot;,&quot;, obj);</span>
            }
            else
            {
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">                if(isSimpleType(obj))</span>
                {
<span class="fc" id="L816">                    value = obj.toString();</span>
                }
                else
                {
<span class="nc" id="L820">                    throw new VariableExpansionException(&quot;Collections or other complex types are not supported in collections.&quot;);</span>
                }
            }

<span class="fc" id="L824">            stringValues.add(expandStringValue(operator, varSpec, value, VarSpec.VarFormat.ARRAY));</span>
<span class="fc" id="L825">        }</span>

<span class="fc bfc" id="L827" title="All 4 branches covered.">        if (varSpec.getModifier() != Modifier.EXPLODE &amp;&amp; operator.useVarNameWhenExploded())</span>
        {
<span class="fc" id="L829">            final String parts = joinParts(separator, stringValues);</span>
<span class="pc bpc" id="L830" title="1 of 4 branches missed.">            if (operator == Operator.QUERY &amp;&amp; parts == null)</span>
            {
<span class="nc" id="L832">                return varSpec.getVariableName() + &quot;=&quot;;</span>
            }
<span class="fc" id="L834">            return varSpec.getVariableName() + &quot;=&quot; + parts;</span>
        }
<span class="fc" id="L836">        return joinParts(separator, stringValues);</span>
    }

    /**
     * Check to ensure that the values being passed down do not contain nested data structures.
     *
     * @param obj
     */
    private boolean checkValue(Object obj) throws VariableExpansionException
    {
<span class="fc bfc" id="L846" title="All 2 branches covered.">        if (obj instanceof Map)</span>
        {
<span class="fc" id="L848">            throw new VariableExpansionException(&quot;Nested data structures are not supported.&quot;);</span>
        }

<span class="pc bpc" id="L851" title="1 of 4 branches missed.">        if (obj instanceof Collection || obj.getClass().isArray())</span>
        {
<span class="fc" id="L853">            return true;</span>
        }
<span class="fc" id="L855">        return false;</span>
    }

    /**
     * @param operator
     * @param varSpec
     * @param variable
     * @return
     */
    private String expandMap(Operator operator, VarSpec varSpec, Map&lt;String, Object&gt; variable)
    throws VariableExpansionException
    {
<span class="pc bpc" id="L867" title="1 of 4 branches missed.">        if (variable == null || variable.isEmpty())</span>
        {
<span class="fc" id="L869">            return null;</span>
        }

<span class="fc" id="L872">        List&lt;String&gt; stringValues = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L873">        String pairJoiner = &quot;=&quot;;</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">        if (varSpec.getModifier() != Modifier.EXPLODE)</span>
        {
<span class="fc" id="L876">            pairJoiner = &quot;,&quot;;</span>
        }
<span class="fc" id="L878">        String joiner = operator.getSeparator();</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">        if (varSpec.getModifier() != Modifier.EXPLODE)</span>
        {
<span class="fc" id="L881">            joiner = operator.getListSeparator();</span>
        }
<span class="fc bfc" id="L883" title="All 2 branches covered.">        for (Entry&lt;String, Object&gt; entry : variable.entrySet())</span>
        {

<span class="fc" id="L886">            String key = entry.getKey();</span>
            String value;
<span class="fc bfc" id="L888" title="All 2 branches covered.">            if(checkValue(entry.getValue()))</span>
            {
<span class="fc" id="L890">                value = joinParts(&quot;,&quot;, entry.getValue());</span>
            }
            else
            {
<span class="fc bfc" id="L894" title="All 2 branches covered.">                if(isSimpleType(entry.getValue()))</span>
                {
<span class="fc" id="L896">                    value = entry.getValue().toString();</span>
                }
                else
                {
<span class="fc" id="L900">                    throw new VariableExpansionException(&quot;Collections or other complex types are not supported in collections.&quot;);</span>
                }
            }

<span class="fc" id="L904">            String pair = expandStringValue(operator, varSpec, key, VarSpec.VarFormat.PAIRS) + pairJoiner</span>
<span class="fc" id="L905">            + expandStringValue(operator, varSpec, value, VarSpec.VarFormat.PAIRS);</span>

<span class="fc" id="L907">            stringValues.add(pair);</span>
<span class="fc" id="L908">        }</span>

<span class="fc bfc" id="L910" title="All 8 branches covered.">        if (varSpec.getModifier() != Modifier.EXPLODE</span>
        &amp;&amp; (operator == Operator.MATRIX || operator == Operator.QUERY || operator == Operator.CONTINUATION))
        {
<span class="fc" id="L913">            String joinedValues = joinParts(joiner, stringValues);</span>
<span class="pc bpc" id="L914" title="1 of 4 branches missed.">            if (operator == Operator.QUERY &amp;&amp; joinedValues == null)</span>
            {
<span class="nc" id="L916">                return varSpec.getVariableName() + &quot;=&quot;;</span>
            }
<span class="fc" id="L918">            return varSpec.getVariableName() + &quot;=&quot; + joinedValues;</span>
        }

<span class="fc" id="L921">        return joinParts(joiner, stringValues);</span>
    }

    /**
     * This method performs the expansion on the string value being applied to the output URI. The rules for exapnasion
     * depends heavily on the {@link Operator} in use. The {@link Operator} will dictate the URI encoding rules that
     * will be applied to the string.
     *
     *
     * @param operator
     * @param varSpec
     * @param variable
     * @param format
     * @return
     */
    private String expandStringValue(Operator operator, VarSpec varSpec, String variable, VarSpec.VarFormat format)
    throws VariableExpansionException
    {
        String expanded;

<span class="fc bfc" id="L941" title="All 2 branches covered.">        if (varSpec.getModifier() == Modifier.PREFIX)</span>
        {
<span class="fc" id="L943">            int position = varSpec.getPosition();</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">            if (position &lt; variable.length())</span>
            {
<span class="fc" id="L946">                variable = variable.substring(0, position);</span>
            }
        }

        try
        {
            // If we have a {+} or {#} operator, there are items we do not need to encode.
<span class="fc bfc" id="L953" title="All 2 branches covered.">            if (operator.getEncoding() == Encoding.UR)</span>
            {
<span class="fc" id="L955">                expanded = UriUtil.encodeFragment(variable);</span>
            }
            else
            {
<span class="fc" id="L959">                expanded = UriUtil.encode(variable);</span>
            }
        }
<span class="nc" id="L962">        catch (UnsupportedEncodingException e)</span>
        {
<span class="nc" id="L964">            throw new VariableExpansionException(&quot;Could not expand variable due to a problem URI encoding the value.&quot;, e);</span>
<span class="fc" id="L965">        }</span>

<span class="fc bfc" id="L967" title="All 2 branches covered.">        if (operator.isNamed())</span>
        {
<span class="fc bfc" id="L969" title="All 4 branches covered.">            if (expanded.isEmpty() &amp;&amp; !&quot;&amp;&quot;.equals(operator.getSeparator()) )</span>
            {
<span class="fc" id="L971">                expanded = varSpec.getValue();</span>
            }
<span class="fc bfc" id="L973" title="All 2 branches covered.">            else if (format == VarSpec.VarFormat.SINGLE)</span>
            {
<span class="fc" id="L975">                expanded = varSpec.getVariableName() + &quot;=&quot; + expanded;</span>
            }

            else
            {
<span class="fc bfc" id="L980" title="All 2 branches covered.">                if (varSpec.getModifier() == Modifier.EXPLODE &amp;&amp;</span>
<span class="pc bpc" id="L981" title="1 of 4 branches missed.">                    operator.useVarNameWhenExploded() &amp;&amp;</span>
                    format != VarSpec.VarFormat.PAIRS)
                    {
<span class="fc" id="L984">                        expanded = varSpec.getVariableName() + &quot;=&quot; + expanded;</span>
                    }

            }
        }
<span class="fc" id="L989">        return expanded;</span>
    }


    private String joinParts(final String joiner, Object parts)
    {
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">        if(parts instanceof Collection)</span>
        {
<span class="fc" id="L997">            Collection&lt;String&gt; values = (Collection)parts;</span>
<span class="fc" id="L998">            List&lt;String&gt; v = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">            for(String s : values)</span>
            {
<span class="fc" id="L1001">                v.add(s);</span>
<span class="fc" id="L1002">            }</span>
<span class="fc" id="L1003">            return joinParts(joiner,v);</span>
        }
<span class="nc bnc" id="L1005" title="All 2 branches missed.">        else if (parts.getClass().isArray())</span>
        {
<span class="nc" id="L1007">            List&lt;String&gt; v = Arrays.asList((String[]) parts);</span>
<span class="nc" id="L1008">            return joinParts(joiner,v);</span>
        }
<span class="nc" id="L1010">        return null;</span>

    }
    /**
     * @param joiner
     * @param parts
     * @return
     */
    private String joinParts(final String joiner, List&lt;String&gt; parts)
    {
<span class="fc bfc" id="L1020" title="All 2 branches covered.">        if (parts.isEmpty())</span>
        {
<span class="fc" id="L1022">            return null;</span>
        }

<span class="fc bfc" id="L1025" title="All 2 branches covered.">        if (parts.size() == 1)</span>
        {
<span class="fc" id="L1027">            return parts.get(0);</span>
        }

<span class="fc" id="L1030">        final StringBuilder builder = new StringBuilder();</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">        for (int i = 0; i &lt; parts.size(); i++)</span>
        {
<span class="fc" id="L1033">            final String part = parts.get(i);</span>
<span class="fc bfc" id="L1034" title="All 2 branches covered.">            if (!part.isEmpty())</span>
            {
<span class="fc" id="L1036">                builder.append(part);</span>
<span class="pc bpc" id="L1037" title="1 of 4 branches missed.">                if (parts.size() &gt; 0 &amp;&amp; i != (parts.size() - 1))</span>
                {
<span class="fc" id="L1039">                    builder.append(joiner);</span>
                }
            }

        }
<span class="fc" id="L1044">        return builder.toString();</span>
    }

   /**
    * Joins parts by preserving expressions without values.
    * @param expression Expression for the given parts
    * @param parts Parts to join
    * @return Joined parts
    */
   private String joinParts(final Expression expression, List&lt;String&gt; parts)
   {

<span class="fc" id="L1056">      int[] index = getIndexForPartsWithNullsFirstIfQueryOrRegularSequnceIfNot(expression, parts);</span>

<span class="fc" id="L1058">      List&lt;String&gt; replacedParts = new ArrayList&lt;String&gt;(parts.size());</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">      for(int i = 0; i &lt; parts.size(); i++) {</span>
<span class="fc" id="L1060">         StringBuilder builder = new StringBuilder();</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">         if(parts.get(index[i]) == null)</span>
         {
<span class="fc" id="L1063">            builder.append('{');</span>
<span class="fc bfc" id="L1064" title="All 4 branches covered.">            while(i &lt; parts.size() &amp;&amp; parts.get(index[i]) == null)</span>
            {
<span class="fc bfc" id="L1066" title="All 2 branches covered.">               if(builder.length() == 1)</span>
               {
<span class="fc bfc" id="L1068" title="All 2 branches covered.">                  builder.append(replacedParts.size() == 0 ? expression.getOperator().getPrefix() : expression.getOperator().getSeparator());</span>
               }
               else
               {
<span class="fc" id="L1072">                  builder.append(DEFAULT_SEPARATOR);</span>
               }
<span class="fc" id="L1074">               builder.append(expression.getVarSpecs().get(index[i]).getValue());</span>
<span class="fc" id="L1075">               i++;</span>
            }
<span class="fc" id="L1077">            i--;</span>
<span class="fc" id="L1078">            builder.append('}');</span>
         } else {
<span class="fc bfc" id="L1080" title="All 2 branches covered.">           if(expression.getOperator() != Operator.RESERVED) {</span>
<span class="fc bfc" id="L1081" title="All 2 branches covered.">            builder.append(replacedParts.size() == 0 ? expression.getOperator().getPrefix() : expression.getOperator().getSeparator());</span>
           }
<span class="fc" id="L1083">           builder.append(parts.get(index[i]));</span>
         }
<span class="fc" id="L1085">         replacedParts.add(builder.toString());</span>
      }
<span class="fc" id="L1087">      return joinParts(&quot;&quot;, replacedParts);</span>
   }

   /**
    * Takes an array of objects and converts them to a {@link List}.
    *
    * @param array
    * @return
    */
   private List&lt;Object&gt; arrayToList(Object array) throws VariableExpansionException
   {
<span class="fc" id="L1098">      List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L1099">      int length = Array.getLength(array);</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">      for (int i = 0; i &lt; length; i++)</span>
      {
<span class="fc" id="L1102">         final Object element = Array.get(array, i);</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">         if (element.getClass().isArray())</span>
         {
<span class="fc" id="L1105">            throw new VariableExpansionException(&quot;Multi-dimenesional arrays are not supported.&quot;);</span>
         }
<span class="fc" id="L1107">         list.add(element);</span>
      }
<span class="fc" id="L1109">      return list;</span>
   }

   /**
    * Takes the expression and the parts and generate a index with null value parts pulled to the start and
    * the not null value parts pushed to the end. Ex:
    * [&quot;var3&quot;,null,&quot;var1&quot;,null] will generate the following index:
    * [1,3,0,2]
    * @param expression
    * @param parts
    * @return
    */
   private int[] getIndexForPartsWithNullsFirstIfQueryOrRegularSequnceIfNot(final Expression expression, List&lt;String&gt; parts)
   {
<span class="fc" id="L1123">      int[] index = new int[parts.size()];</span>

<span class="fc" id="L1125">      int inverse, forward = 0, backward = parts.size() - 1;</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">      for (int i = 0; i &lt; parts.size(); i++) {</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">         if (expression.getOperator() == Operator.QUERY)</span>
         {
<span class="fc" id="L1129">            inverse = parts.size() - i - 1;</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">            if (parts.get(i) != null)</span>
            {
<span class="fc" id="L1132">               index[forward++] = i;</span>
            }
<span class="fc bfc" id="L1134" title="All 2 branches covered.">            if (parts.get(inverse) == null)</span>
            {
<span class="fc" id="L1136">               index[backward--] = inverse;</span>
            }
         }
         else
         {
<span class="fc" id="L1141">            index[i] = i;</span>
         }
      }
<span class="fc" id="L1144">      return index;</span>
   }




   /**
    *
    *
    * @return
    */
//   public String getRegexString()
//   {
//      return null;
//   }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>