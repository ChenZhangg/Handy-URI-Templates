<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Expression.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Handy URI Templates</a> &gt; <a href="index.source.html" class="el_package">com.damnhandy.uri.template</a> &gt; <span class="el_source">Expression.java</span></div><h1>Expression.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2012, Ryan J. McDonough
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.damnhandy.uri.template;


import com.damnhandy.uri.template.impl.Modifier;
import com.damnhandy.uri.template.impl.Operator;
import com.damnhandy.uri.template.impl.VarSpec;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * &lt;p&gt;
 * An Expression represents the text between '{' and '}', including the enclosing
 * braces, as defined in &lt;a href=&quot;ietf.org/html/rfc6570#section-2&quot;&gt;Section 2 of RFC6570&lt;/a&gt;.
 * &lt;/p&gt;
 * &lt;pre&gt;
 * http://www.example.com/foo{?query,number}
 *                            \___________/
 *                                  ^
 *                                  |
 *                                  |
 *                            The expression
 * &lt;/pre&gt;
 * &lt;p&gt;
 * This class models this representation and adds helper functions for replacement and reverse matching.
 * &lt;/p&gt;
 *
 * @author &lt;a href=&quot;ryan@damnhandy.com&quot;&gt;Ryan J. McDonough&lt;/a&gt;
 * @version $Revision: 1.1 $
 * @since 2.0
 */
public class Expression extends UriTemplateComponent
{

    /**
     * The serialVersionUID
     */
    private static final long serialVersionUID = -5305648325957481840L;

    /**
     * A regex quoted string that matches the expression for replacement in the
     * expansion process. For example:
     * &lt;pre&gt;
     *          \Q{?query,number}\E
     * &lt;/pre&gt;
     */
    private String replacementPattern;

    /**
     * That {@link Operator} value that is associated with this Expression
     */
    private Operator op;

    /**
     * The character position where this expression occurs in the URI template
     */
    private final int location;
    /**
     * The the parsed {@link VarSpec} instances found in the expression.
     */
    private List&lt;VarSpec&gt; varSpecs;

    /**
     * The Patter that would be used to reverse match this expression
     */
    private Pattern matchPattern;


    /**
     * Creates a new {@link Builder} to create a simple expression according
     * to section &lt;a href=&quot;http://tools.ietf.org/html/rfc6570#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt;.
     * Calling:
     * &lt;pre&gt;
     * String exp = Expression.simple(var(&quot;var&quot;)).build().toString();
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Will return the following expression:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * {var}
     * &lt;/pre&gt;
     *
     * @return
     */
    public static Builder simple(VarSpec... varSpec)
    {
<span class="fc" id="L104">        return Builder.create(Operator.NUL, varSpec);</span>
    }


    /**
     * Creates a new {@link Builder} to create an expression that will use reserved expansion
     * according to section &lt;a href=&quot;http://tools.ietf.org/html/rfc6570#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt;.
     * Calling:
     * &lt;pre&gt;
     * String exp = Expression.reserved().var(&quot;var&quot;).build().toString();
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Will return the following expression:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * {+var}
     * &lt;/pre&gt;
     *
     * @return
     */
    public static Builder reserved(VarSpec... varSpec)
    {
<span class="fc" id="L126">        return Builder.create(Operator.RESERVED, varSpec);</span>
    }

    /**
     * Creates a new {@link Builder} to create an expression with a fragment operator
     * according to section &lt;a href=&quot;http://tools.ietf.org/html/rfc6570#section-3.2.4&quot;&gt;3.2.4&lt;/a&gt;.
     * Calling:
     * &lt;pre&gt;
     * String exp = Expression.fragment().var(&quot;var&quot;).build().toString();
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Will return the following expression:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * {#var}
     * &lt;/pre&gt;
     *
     * @return
     */
    public static Builder fragment(VarSpec... varSpec)
    {
<span class="fc" id="L147">        return Builder.create(Operator.FRAGMENT, varSpec);</span>
    }

    /**
     * Creates a new {@link Builder} to create an expression using label expansion
     * according to section &lt;a href=&quot;http://tools.ietf.org/html/rfc6570#section-3.2.5&quot;&gt;3.2.5&lt;/a&gt;.
     * Calling:
     * &lt;pre&gt;
     * String exp = Expression.label(var(&quot;var&quot;)).build().toString();
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Will return the following expression:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * {.var}
     * &lt;/pre&gt;
     *
     * @return
     */
    public static Builder label(VarSpec... varSpec)
    {
<span class="fc" id="L168">        return Builder.create(Operator.NAME_LABEL, varSpec);</span>
    }

    /**
     * Creates a new {@link Builder} to create an expression using path expansion
     * according to section &lt;a href=&quot;http://tools.ietf.org/html/rfc6570#section-3.2.6&quot;&gt;3.2.6&lt;/a&gt;.
     * Calling:
     * &lt;pre&gt;
     * String exp = Expression.path().var(&quot;var&quot;).build().toString();
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Will return the following expression:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * {/var}
     * &lt;/pre&gt;
     *
     * @return
     */
    public static Builder path(VarSpec... varSpec)
    {
<span class="fc" id="L189">        return Builder.create(Operator.PATH, varSpec);</span>
    }

    /**
     * Creates a new {@link Builder} to create an expression using path-style parameter
     * (a.k.a. matrix parameter) expansion according to
     * section &lt;a href=&quot;http://tools.ietf.org/html/rfc6570#section-3.2.7&quot;&gt;3.2.7&lt;/a&gt;.
     * Calling:
     * &lt;pre&gt;
     * String exp = Expression.matrix().var(&quot;var&quot;).build().toString();
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Will return the following expression:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * {;var}
     * &lt;/pre&gt;
     *
     * @return the builder
     */
    public static Builder matrix(VarSpec... varSpec)
    {
<span class="fc" id="L211">        return Builder.create(Operator.MATRIX, varSpec);</span>
    }

    /**
     * Creates a new {@link Builder} to create an expression using form-style query string expansion
     * according to section &lt;a href=&quot;http://tools.ietf.org/html/rfc6570#section-3.2.8&quot;&gt;3.2.8&lt;/a&gt;.
     * Calling:
     * &lt;pre&gt;
     * String exp = Expression.query().var(&quot;var&quot;).build().toString();
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Will return the following expression:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * {?var}
     * &lt;/pre&gt;
     *
     * @return
     */
    public static Builder query(VarSpec... varSpec)
    {
<span class="fc" id="L232">        return Builder.create(Operator.QUERY, varSpec);</span>
    }

    /**
     * Creates a new {@link Builder} to create an expression using form-style query continuation expansion
     * according to section &lt;a href=&quot;http://tools.ietf.org/html/rfc6570#section-3.2.9&quot;&gt;3.2.9&lt;/a&gt;.
     * Calling:
     * &lt;pre&gt;
     * String exp = Expression.continuation().var(&quot;var&quot;).build().toString();
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Will return the following expression:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * {&amp;amp;var}
     * &lt;/pre&gt;
     *
     * @return
     */
    public static Builder continuation(VarSpec... varSpec)
    {
<span class="fc" id="L253">        return Builder.create(Operator.CONTINUATION, varSpec);</span>
    }


    /**
     * Create a new Expression.
     *
     * @param rawExpression
     * @param startPosition
     * @throws MalformedUriTemplateException
     */
    public Expression(final String rawExpression, final int startPosition) throws MalformedUriTemplateException
    {
<span class="fc" id="L266">        super(startPosition);</span>
<span class="fc" id="L267">        this.location = startPosition;</span>
<span class="fc" id="L268">        this.parseRawExpression(rawExpression);</span>
<span class="fc" id="L269">    }</span>

    /**
     * Create a new Expression
     *
     * @param op
     * @param varSpecs
     * @throws MalformedUriTemplateException
     */
    public Expression(final Operator op, final List&lt;VarSpec&gt; varSpecs)
    {
<span class="fc" id="L280">        super(0);</span>
<span class="fc" id="L281">        this.op = op;</span>
<span class="fc" id="L282">        this.varSpecs = varSpecs;</span>
<span class="fc" id="L283">        this.replacementPattern = Pattern.quote(toString());</span>
<span class="fc" id="L284">        this.location = 0;</span>
<span class="fc" id="L285">    }</span>

    /**
     * @param rawExpression
     * @throws MalformedUriTemplateException
     */
    private void parseRawExpression(String rawExpression) throws MalformedUriTemplateException
    {
<span class="fc" id="L293">        final String expressionReplacement = Pattern.quote(rawExpression);</span>
<span class="fc" id="L294">        String token = rawExpression.substring(1, rawExpression.length() - 1);</span>
        // Check for URI operators
<span class="fc" id="L296">        Operator operator = Operator.NUL;</span>
<span class="fc" id="L297">        String firstChar = token.substring(0, 1);</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (UriTemplate.containsOperator(firstChar))</span>
        {
            try
            {
<span class="fc" id="L302">                operator = Operator.fromOpCode(firstChar);</span>
            }
<span class="fc" id="L304">            catch (IllegalArgumentException e)</span>
            {
<span class="fc" id="L306">                throw new MalformedUriTemplateException(&quot;Invalid operator&quot;, this.location, e);</span>
<span class="fc" id="L307">            }</span>
<span class="fc" id="L308">            token = token.substring(1, token.length());</span>
        }
<span class="fc" id="L310">        String[] varspecStrings = token.split(&quot;,&quot;);</span>
<span class="fc" id="L311">        List&lt;VarSpec&gt; varspecs = new ArrayList&lt;VarSpec&gt;();</span>

<span class="fc bfc" id="L313" title="All 2 branches covered.">        for (String varname : varspecStrings)</span>
        {
<span class="fc" id="L315">            int subStrPos = varname.indexOf(Modifier.PREFIX.getValue());</span>
         /*
          * Prefix variable
          */
<span class="fc bfc" id="L319" title="All 2 branches covered.">            if (subStrPos &gt; 0)</span>
            {
<span class="fc" id="L321">                String[] pair = varname.split(Modifier.PREFIX.getValue());</span>
                try
                {
<span class="fc" id="L324">                    Integer pos = Integer.valueOf(varname.substring(subStrPos + 1));</span>
<span class="fc" id="L325">                    varspecs.add(new VarSpec(pair[0], Modifier.PREFIX, pos));</span>
                }
<span class="fc" id="L327">                catch (NumberFormatException e)</span>
                {
<span class="fc" id="L329">                    throw new MalformedUriTemplateException(&quot;The prefix value for &quot; + pair[0] + &quot; was not a number&quot;, this.location, e);</span>
<span class="fc" id="L330">                }</span>
<span class="fc" id="L331">            }</span>

         /*
          * Variable will be exploded
          */
<span class="fc bfc" id="L336" title="All 2 branches covered.">            else if (varname.lastIndexOf(Modifier.EXPLODE.getValue()) &gt; 0)</span>
            {
<span class="fc" id="L338">                varspecs.add(new VarSpec(varname, Modifier.EXPLODE));</span>
            }
         /*
          * Standard Value
          */
            else
            {
<span class="fc" id="L345">                varspecs.add(new VarSpec(varname, Modifier.NONE));</span>
            }
        }
<span class="fc" id="L348">        this.replacementPattern = expressionReplacement;</span>
<span class="fc" id="L349">        this.op = operator;</span>
<span class="fc" id="L350">        this.varSpecs = varspecs;</span>
<span class="fc" id="L351">    }</span>




    private Pattern buildMatchingPattern()
    {
<span class="nc" id="L358">        StringBuilder b = new StringBuilder();</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">        for (VarSpec v : getVarSpecs())</span>
        {
<span class="nc" id="L361">            b.append(&quot;(?&lt;&quot;).append(v.getVariableName()).append(&quot;&gt;[^\\/]+)&quot;);</span>
<span class="nc" id="L362">        }</span>
<span class="nc" id="L363">        return Pattern.compile(b.toString());</span>
    }

    /**
     * Returns a string that contains a regular expression that matches the
     * URI template expression.
     *
     * @return the match pattern
     */
    @Override
    public Pattern getMatchPattern()
    {
<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (this.matchPattern == null)</span>
        {
<span class="nc" id="L377">            this.matchPattern = buildMatchingPattern();</span>
        }
<span class="nc" id="L379">        return this.matchPattern;</span>
    }

    /**
     * Get the replacementToken.
     *
     * @return the replacementToken.
     */
    public String getReplacementPattern()
    {
<span class="fc" id="L389">        return replacementPattern;</span>
    }

    /**
     * Get the {@link Operator} value for this expression.
     *
     * @return the operator value.
     */
    public Operator getOperator()
    {
<span class="fc" id="L399">        return op;</span>
    }

    /**
     * Get the varSpecs.
     *
     * @return the varSpecs.
     */
    public List&lt;VarSpec&gt; getVarSpecs()
    {
<span class="fc" id="L409">        return varSpecs;</span>
    }

    /**
     * Returns the string representation of the expression.
     *
     * @see Object#toString()
     */
    public String toString()
    {
<span class="fc" id="L419">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L420">        b.append(&quot;{&quot;).append(this.getOperator().getOperator());</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">        for (int i = 0; i &lt; varSpecs.size(); i++)</span>
        {
<span class="fc" id="L423">            VarSpec v = varSpecs.get(i);</span>
<span class="fc" id="L424">            b.append(v.getValue());</span>
            // Double check that the value doesn't already contain the modifier
<span class="fc" id="L426">            int r = v.getValue().lastIndexOf(v.getModifier().getValue());</span>
<span class="pc bpc" id="L427" title="1 of 4 branches missed.">            if(v.getModifier() != null &amp;&amp; v.getValue().lastIndexOf(v.getModifier().getValue()) == -1)</span>
            {
<span class="fc" id="L429">                b.append(v.getModifier().getValue());</span>
            }

<span class="fc bfc" id="L432" title="All 2 branches covered.">            if (v.getModifier() == Modifier.PREFIX)</span>
            {
<span class="fc" id="L434">                b.append(v.getPosition());</span>
            }
<span class="fc bfc" id="L436" title="All 2 branches covered.">            if (i != (varSpecs.size() - 1))</span>
            {
<span class="fc" id="L438">                b.append(&quot;,&quot;);</span>
            }
        }
<span class="fc" id="L441">        return b.append(&quot;}&quot;).toString();</span>
    }

    /**
     * Returns the value of this component
     *
     * @return the string value of this component.
     */
    @Override
    public String getValue()
    {
<span class="fc" id="L452">        return toString();</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L458">        final int prime = 31;</span>
<span class="nc" id="L459">        int result = 1;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">        result = prime * result + ((op == null) ? 0 : op.hashCode());</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        result = prime * result + ((varSpecs == null) ? 0 : varSpecs.hashCode());</span>
<span class="nc" id="L462">        return result;</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (this == obj)</span>
        {
<span class="nc" id="L470">            return true;</span>
        }
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (obj == null)</span>
        {
<span class="nc" id="L474">            return false;</span>
        }
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (getClass() != obj.getClass())</span>
        {
<span class="nc" id="L478">            return false;</span>
        }
<span class="nc" id="L480">        Expression other = (Expression) obj;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (op != other.op)</span>
        {
<span class="nc" id="L483">            return false;</span>
        }
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (varSpecs == null)</span>
        {
<span class="nc bnc" id="L487" title="All 2 branches missed.">            if (other.varSpecs != null)</span>
            {
<span class="nc" id="L489">                return false;</span>
            }
        }
<span class="nc bnc" id="L492" title="All 2 branches missed.">        else if (!varSpecs.equals(other.varSpecs))</span>
        {
<span class="nc" id="L494">            return false;</span>
        }
<span class="nc" id="L496">        return true;</span>
    }


    /**
     * Builder class for creating an {@link Expression}.
     *
     * @author &lt;a href=&quot;ryan@damnhandy.com&quot;&gt;Ryan J. McDonough&lt;/a&gt;
     * @version $Revision: 1.1 $
     */
    public static class Builder
    {
        /**
         *
         */
        private Operator operator;

        /**
         *
         */
        private List&lt;VarSpec&gt; varSpecs;

        /**
         * Create a new ExpressionBuilder.
         *
         * @param operator
         */
        private Builder(Operator operator, VarSpec... varSpec)
<span class="fc" id="L524">        {</span>
<span class="fc" id="L525">            this.operator = operator;</span>
<span class="fc" id="L526">            this.varSpecs = new ArrayList&lt;VarSpec&gt;();</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">            for (VarSpec v : varSpec)</span>
            {
<span class="fc" id="L529">                varSpecs.add(v);</span>
            }
<span class="fc" id="L531">        }</span>

        /**
         * @param operator
         * @return the builder
         */
        static Builder create(Operator operator, VarSpec... varSpec)
        {
<span class="fc" id="L539">            return new Builder(operator, varSpec);</span>
        }


        public Expression build()
        {
<span class="fc" id="L545">            return new Expression(operator, varSpecs);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>